""" rrt_planner for CAP6990 Applied Robotics Assignment_4

Author: Erik C. LaBrot
Email: ecb25@students.uwf.edu
Date: 2/22/2025

This module defines a rapidly expanding random tree, and functions that
verify the feasibility of paths generated by this RRT based on a provided
set of obstacles and a bounding box that defines a robot navigating along
said paths.
"""

import random
import math
from shapely.geometry import Point, LineString, Polygon
from shapely.affinity import rotate, translate
import matplotlib.pyplot as plt


class RRTPlanner:
    """
    RRT-based motion planner
    Methods: 
        random_state: generate random state within map
        euclid_dist: calculate Euclidean distance between two nodes
        nearest_neighbor: find nearest node in tree to given pose
        simulate_input: simulate robot movement given velocities
        generate_map: create obstacle polygons from points
        feasibility_check: check if new node is collision-free
        line_check: check if path between two nodes is collision-free
        grow_tree: expand RRT tree from start node
        climb_tree: build path from goal to start by tracing tree
        get_path:return generated path
        plot_tree: visualize RRT tree
    Attributes: 
        start: start pose of robot
        goal: goal pose of robot
        map_size: half-dimension of square map
        obs_points: list of obstacle points
        obs list: of obstacle polygons
        robot_bb: robot bounding box as polygon
        dt: time step for motion simulation
        max_it: maximum iterations for tree growth
        vx: maximum linear velocity
        vw: maximum angular velocity
        accept_radius: goal acceptance radius
        path_found: flag indicating if path was found
        tree: RRT tree storing nodes and parents
        path: list of nodes forming path from start to goal
    """
    def __init__(self, start, goal, map_size, obs, robot_bb, vx, vw, dt=1.0, max_it=5000):
        self.start = start #(x,y,theta)
        self.goal = goal
        self.map_size = map_size
        self.obs_points = obs
        self.obs = []
        self.robot_bb = robot_bb
        self.dt = dt
        self.max_it = max_it

        self.vx = vx
        self.vw = vw

        self.accept_radius = vx*dt
        self.path_found = False

        self.tree = {start : None} #Node : Parent
        self.path = []

    def random_state(self):
        """
        Generate random state within map
        Args: none
        Return: random state as (x, y, theta)
        """
        x = random.uniform(-self.map_size, self.map_size)
        y = random.uniform(-self.map_size, self.map_size)
        theta = random.uniform(-math.pi, math.pi)
        return (x,y, theta)

    def euclid_dist(self, node1, node2):
        """
        Calculate Euclidean distance between two nodes
        Args: node1 first node as (x, y) tuple, node2 second node as (x, y) tuple
        Return: Euclidean distance between nodes
        """
        dx = node1[0] - node2[0]
        dy = node1[1] - node2[1]
        return math.sqrt(dx**2 + dy**2)

    def nearest_neighbor(self, pose):
        """
        Find nearest node in tree to given pose
        Args: pose target pose as (x, y, theta)
        Return: nearest node in tree
        """
        return min(self.tree.keys(), key=lambda node: self.euclid_dist(node, pose))

    def simulate_input(self, node, vx, vw):
        """
        Simulate robot movement given velocities
        Args: node current pose as (x, y, theta), vx linear velocity, vw angular velocity
        Return: new pose after applying velocities
        """
        x, y, theta = node
        x_dot = x + vx * math.cos(theta) * self.dt
        y_dot = y + vx * math.sin(theta) * self.dt
        theta_dot = theta + vw * self.dt

        return (x_dot, y_dot, theta_dot)

    def generate_map(self):
        """
        Create obstacle polygons from points
        Args: none
        Return: none
        """
        obs_size = 1.0
        l = obs_size/2
        for p in self.obs_points:
            poly = Polygon([
                (p[0] - l, p[1] - l),
                (p[0] + l, p[1] - l),
                (p[0] + l, p[1] + l),
                (p[0] - l, p[1] + l)])

            self.obs.append(poly)

    def feasibility_check(self, p_new, p_near):
        """
        Check if new node is collision-free
        Args: p_new new node, p_near nearest node in tree
        Return: True if collision-free, False otherwise
        """
        dx = p_new[0] - p_near[0]
        dy = p_new[1] - p_near[1]
        theta = math.atan2(dy,dx)

        tf_box = translate(self.robot_bb, p_new[0], p_new[1])
        tf_box = rotate(tf_box, theta, origin=(p_new[0], p_new[1]), use_radians=True)
       
        for obs in self.obs:
            if tf_box.intersects(obs):
                return False  # Not feasible (collision detected)
        return True  # Feasible

    def line_check(self, p1, p2):
        """
        Check if path between two nodes is collision-free
        Args: p1 start node, p2 end node
        Return: True if collision detected, False otherwise
        """
        stepsize = 0.5 #m
        n1 = p1[:2]
        n2 = p2[:2]

        #Assume squre mape
        if abs(n2[0]) > self.map_size or abs(n2[1]) > self.map_size:
            return False

        dx = p2[0] - p1[0]
        dy = p2[1] - p1[1]
        mag = math.sqrt(dx**2 + dy**2)
        ang = math.atan2(dy, dx)
        steps = max(1, int(mag / stepsize))

        for i in range(steps):
            x = p1[0] + (i / steps) * dx
            y = p1[1] + (i / steps) * dy

            tf_box = translate(self.robot_bb, x, y)
            tf_box = rotate(tf_box, ang, origin=(x, y), use_radians=True)

            for obs in self.obs:
                if tf_box.intersects(obs):
                    return True
        return False

    def grow_tree(self, start): #haha, get it
        """
        Expand RRT tree from start node
        Args: start start node
        Return: none
        """
        self.start = start

        self.tree = {self.start : None} #Reset tree
        
        if self.path_found is True:
            return

        self.generate_map()

        for i in range(self.max_it):
            x_rand = self.random_state()
            x_near = self.nearest_neighbor(x_rand)
            vx_rand = random.uniform(0, self.vx)
            vw_rand = random.uniform(-self.vw, self.vw)
            x_new = self.simulate_input(x_near, vx_rand, vw_rand)

            collision = self.line_check(x_near, x_new)
            feasible = self.feasibility_check(x_new, x_near)

            if feasible and not collision:
                self.tree[x_new] = x_near
                if self.euclid_dist(self.goal, x_new) < self.accept_radius:
                    self.tree[self.goal] = x_new
                    self.climb_tree()
                    self.path_found = True
                    return #We only need one path, save some computation time and RAM

    def climb_tree(self):
        """
        Build path from goal to start by tracing tree
        Args: none
        Return: none
        """
        cur = self.goal

        while cur is not None:
            self.path.append(cur)
            cur = self.tree.get(cur)

        self.path.reverse()

    def get_path(self):
        """
        Return generated path
        Args: none
        Return: list of nodes forming path
        """
        return self.path


    def plot_tree(self):
        """Visualize RRT tree
        Args: none
        Return: none
        """
        fig, ax = plt.subplots()

        for obs in self.obs:
            x, y = obs.exterior.xy
            ax.fill(x, y, color='red')

        for node, parent in self.tree.items():
            ax.scatter(node[0], node[1], color='blue', s=10)
            if parent:
                ax.plot([parent[0], node[0]], [parent[1], node[1]], color='black', linewidth=0.1)

        ax.scatter(self.start[0], self.start[1], color='green', s=100, zorder=5)
        ax.scatter(self.goal[0], self.goal[1], color='blue', s=100, zorder=5)

        ax.set_xlim(-self.map_size, self.map_size)
        ax.set_ylim(-self.map_size, self.map_size)
        plt.show()

def plot_path(rrt_planner):
    """Plot path generated by RRTPlanner
    Args: rrt_planner instance of RRTPlanner
    Return: none
    """
    fig, ax = plt.subplots()
    
    for obs in rrt_planner.obs:
        x, y = obs.exterior.xy
        ax.fill(x, y, color='red')

    ax.scatter(rrt_planner.start[0], rrt_planner.start[1], color='green',s=100, zorder=5)
    ax.scatter(rrt_planner.goal[0], rrt_planner.goal[1], color='blue',s=100, zorder=5)

    path = rrt_planner.get_path()
    if path:
        path_x = [p[0] for p in path]
        path_y = [p[1] for p in path]
        ax.plot(path_x, path_y, color='orange', linewidth=2)

    ax.set_xlim(-rrt_planner.map_size, rrt_planner.map_size)
    ax.set_ylim(-rrt_planner.map_size, rrt_planner.map_size)
    plt.show()


def main(args=None):
    map_size = 10
    
    robot_bb = Polygon([(-0.5, -0.5), (0.5, -0.5), (0.5, 0.5), (-0.5, 0.5)])
    
    obstacles = [
        Polygon([(-3, -3), (3, -3), (3, 3), (-3, 3)]), 
        Polygon([(5, -7), (5, -5), (7, -5), (7, -7)])   
    ]
    
    start = (-8, -8, 0) 
    goal = (8, 8, math.pi/2)  

    vx = 1.0  
    vw = math.pi/4  
    dt = 0.75 
    max_it = 5000
    
    # Initialize the RRT planner
    rrt_planner = RRTPlanner(start=start, goal=goal, map_size=map_size, obs=obstacles, 
                              robot_bb=robot_bb, vx=vx, vw=vw, dt=dt, max_it=max_it)
    
    rrt_planner.grow_tree()

    print("Maybe found path, preparing to print")
    
    print(len(rrt_planner.get_path()))

    rrt_planner.plot_tree()

    plot_path(rrt_planner)

if __name__ == "__main__":
    main()